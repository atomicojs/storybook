{"version":3,"file":"decorator-7300498a.js","sources":["../../../../node_modules/atomico/src/utils.js","../../../../node_modules/atomico/src/element/errors.js","../../../../node_modules/atomico/src/element/set-prototype.js","../../../../node_modules/atomico/src/hooks/create-hooks.js","../../../../node_modules/atomico/src/element/custom-element.js","../../../../node_modules/atomico/src/hooks/use-effect.js","../../../../node_modules/atomico/src/options.js","../../../../node_modules/atomico/src/render.js","../../../plugin/dist/decorator.js"],"sourcesContent":["/**\n * compare 2 array\n * ```js\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\n * isEqualArray([1,2,3,4],[1,2,3])   // false\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\n * isEqualArray([],[]) // true\n * ```\n * @param {any[]} before\n * @param {any[]} after\n * @returns {boolean}\n */\nexport function isEqualArray(before, after) {\n    const length = before.length;\n    if (length !== after.length) return false;\n    for (let i = 0; i < length; i++) {\n        if (before[i] !== after[i]) return false;\n    }\n    return true;\n}\n/**\n * Determine if the value is considered a function\n * @type {import(\"internal/utils\").IsFunction}\n */\nexport const isFunction = (value) => typeof value == \"function\";\n\n/**\n * Determines if the value is considered an object\n * @param {any} value\n */\nexport const isObject = (value) => typeof value == \"object\";\n\nexport const { isArray } = Array;\n\n/**\n *\n * @param {Element & {dataset?:object}} node\n * @returns\n */\nexport const isHydrate = (node) => \"hydrate\" in (node?.dataset || {});\n\n/**\n * @template {any[]} T\n * @param {T} list\n * @param {(value:T[0])=>void} callback\n */\nexport function flat(list, callback) {\n    let last;\n    /**\n     * @param {any[]} list\n     */\n    const reduce = (list) => {\n        let { length } = list;\n        for (let i = 0; i < length; i++) {\n            const value = list[i];\n            if (value && Array.isArray(value)) {\n                reduce(value);\n            } else {\n                const type = typeof value;\n                if (\n                    value == null ||\n                    type === \"function\" ||\n                    type === \"boolean\"\n                ) {\n                    continue;\n                } else if (type === \"string\" || type === \"number\") {\n                    if (last == null) last = \"\";\n                    last += value;\n                } else {\n                    if (last != null) {\n                        callback(last);\n                        last = null;\n                    }\n                    callback(value);\n                }\n            }\n        }\n    };\n\n    reduce(list);\n\n    if (last != null) callback(last);\n}\n\n/**\n *\n * @param {Element} target\n * @param {string} type\n * @param {(event:Event)=>void} handler\n */\nexport const addListener = (target, type, handler) => {\n    target.addEventListener(type, handler);\n    return () => target.removeEventListener(type, handler);\n};\n","export class Error {\n    /**\n     *\n     * @param {HTMLElement} target\n     * @param {string} message\n     * @param {string} value\n     */\n    constructor(target, message, value) {\n        this.message = message;\n        this.target = target;\n        this.value = value;\n    }\n}\n\nexport class PropError extends Error {}\n\nexport class ParseError extends Error {}\n","import { isObject, isFunction } from \"../utils.js\";\nimport { PropError } from \"./errors.js\";\n/**\n * The Any type avoids the validation of prop types\n * @type {null}\n **/\nexport const Any = null;\n\n/**\n * Attributes considered as valid boleanos\n **/\nconst TRUE_VALUES = { true: 1, \"\": 1, 1: 1 };\n\n/**\n * Constructs the setter and getter of the associated property\n * only if it is not defined in the prototype\n * @param {Object} prototype - CustomElement prototype\n * @param {string} prop - Name of the reactive property to associate with the customElement\n * @param {any} schema - Structure to be evaluated for the definition of the property\n * @param {Attrs} attrs - Dictionary of attributes to properties\n * @param {Values} values - Values to initialize the customElements\n */\nexport function setPrototype(prototype, prop, schema, attrs, values) {\n    /**@type {Schema} */\n    const {\n        type,\n        reflect,\n        event,\n        value,\n        attr = getAttr(prop),\n    } = isObject(schema) && schema != Any ? schema : { type: schema };\n\n    const isCallable = !(type == Function || type == Any);\n\n    Object.defineProperty(prototype, prop, {\n        configurable: true,\n        /**\n         * @this {import(\"dom\").AtomicoThisInternal}\n         * @param {any} newValue\n         */\n        set(newValue) {\n            const oldValue = this[prop];\n            const { error, value } = filterValue(\n                type,\n                isCallable && isFunction(newValue)\n                    ? newValue(oldValue)\n                    : newValue\n            );\n            if (error && value != null) {\n                throw new PropError(\n                    this,\n                    `The value defined for prop '${prop}' must be of type '${type.name}'`,\n                    value\n                );\n            }\n\n            if (oldValue == value) return;\n\n            this._props[prop] = value == null ? undefined : value;\n\n            this.update();\n            /**\n             * 1.7.0 >, this position reduces the amount of updates to the DOM and render\n             */\n            event && dispatchEvent(this, event);\n            /**\n             * attribute mirroring must occur if component is mounted\n             */\n            this.updated.then(() => {\n                if (reflect) {\n                    this._ignoreAttr = attr;\n                    reflectValue(this, type, attr, this[prop]);\n                    this._ignoreAttr = null;\n                }\n            });\n        },\n        /**\n         * @this {import(\"dom\").AtomicoThisInternal}\n         */\n        get() {\n            return this._props[prop];\n        },\n    });\n\n    if (value != null) values[prop] = value;\n\n    attrs[attr] = { prop, type };\n}\n\n/**\n * Dispatch an event\n * @param {Element} node - DOM node to dispatch the event\n * @param {InternalEvent & InternalEventInit} event - Event to dispatch on node\n */\nexport const dispatchEvent = (\n    node,\n    { type, base = CustomEvent, ...eventInit }\n) => node.dispatchEvent(new base(type, eventInit));\n\n/**\n * Transform a Camel Case string to a Kebab case\n * @param {string} prop - string to apply the format\n * @returns {string}\n */\nexport const getAttr = (prop) => prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n\n/**\n * reflects an attribute value of the given element as context\n * @param {Element} host\n * @param {any} type\n * @param {string} attr\n * @param {any} value\n */\nexport const reflectValue = (host, type, attr, value) =>\n    value == null || (type == Boolean && !value)\n        ? host.removeAttribute(attr)\n        : host.setAttribute(\n              attr,\n              isObject(value)\n                  ? JSON.stringify(value)\n                  : type == Boolean\n                  ? \"\"\n                  : value\n          );\n\n/**\n * transform a string to a value according to its type\n * @param {any} type\n * @param {string} value\n * @returns {any}\n */\nexport const transformValue = (type, value) =>\n    type == Boolean\n        ? !!TRUE_VALUES[value]\n        : type == Number\n        ? Number(value)\n        : type == Array || type == Object\n        ? JSON.parse(value)\n        : value;\n/**\n * Filter the values based on their type\n * @param {any} type\n * @param {any} value\n * @returns {{error?:boolean,value:any}}\n */\nexport const filterValue = (type, value) =>\n    type == null || value == null\n        ? { value, error: false }\n        : type != String && value === \"\"\n        ? { value: undefined, error: false }\n        : type == Object || type == Array || type == Symbol\n        ? { value, error: {}.toString.call(value) !== `[object ${type.name}]` }\n        : value instanceof type\n        ? { value, error: type == Number && Number.isNaN(value.valueOf()) }\n        : type == String || type == Number || type == Boolean\n        ? {\n              value,\n              error:\n                  type == Number\n                      ? typeof value != \"number\"\n                          ? true\n                          : Number.isNaN(value)\n                      : type == String\n                      ? typeof value != \"string\"\n                      : typeof value != \"boolean\",\n          }\n        : { value, error: true };\n/**\n * Type any, used to avoid type validation.\n * @typedef {null} Any\n */\n\n/**\n * @typedef {Object} InternalEventInit\n * @property {typeof CustomEvent|typeof Event} [base] - Optional constructor to initialize the event\n * @property {boolean} [bubbles] - indicating whether the event bubbles. The default is false.\n * @property {boolean} [cancelable] - indicating whether the event will trigger listeners outside of a shadow root.\n * @property {boolean} [composed] - indicating whether the event will trigger listeners outside of a shadow root.\n * @property {any} [detail] - indicating whether the event will trigger listeners outside of a shadow root.\n */\n\n/**\n * Interface used by dispatchEvent to automate event firing\n * @typedef {Object} InternalEvent\n * @property {string} type - type of event to dispatch.\n */\n\n/**\n * @typedef {Object<string, {prop:string,type:Function}>} Attrs\n */\n\n/**\n * @typedef {Object<string, any>} Values\n */\n\n/**\n * @typedef {Object} Schema\n * @property {any} [type] - data type to be worked as property and attribute\n * @property {string} [attr] - allows customizing the name as an attribute by skipping the camelCase format\n * @property {boolean} [reflect] - reflects property as attribute of node\n * @property {InternalEvent & InternalEventInit} [event] - Allows to emit an event every time the property changes\n * @property {any} [value] - defines a default value when instantiating the component\n */\n","/**\n * @type {import(\"internal/hooks\").SCOPE}\n */\nlet SCOPE;\n\n/**\n * Error id to escape execution of hooks.load\n */\nexport const IdSuspense = Symbol();\n\n/**\n * tag to identify the useEffect\n */\nexport const IdEffect = Symbol(\"Effect\");\n\n/**\n * tag to identify the useLayoutEffect\n */\nexport const IdLayoutEffect = Symbol(\"LayoutEffect\");\n\n/**\n * tag to identify the useInsertionEffect\n */\nexport const IdInsertionEffect = Symbol(\"InsertionEffect\");\n\n/**\n * @type {import(\"core\").UseHook}\n */\nexport const useHook = (render, effect, tag) => {\n    const { i, hooks } = SCOPE;\n\n    const hook = (hooks[i] = hooks[i] || {});\n\n    hook.value = render(hook.value);\n    hook.effect = effect;\n    hook.tag = tag;\n\n    SCOPE.i++;\n\n    return hooks[i].value;\n};\n\n/**\n * @type {import(\"core\").UseRef}\n */\nexport const useRef = (current) => useHook((ref = { current }) => ref);\n\n/**\n * return the global host of the scope\n * @type {import(\"core\").UseHost}\n */\nexport const useHost = () => useHook((ref = { current: SCOPE.host }) => ref);\n\n/**\n * hook that retrieves the render to restart the loop\n * @type {import(\"core\").UseUpdate}\n */\nexport const useUpdate = () => SCOPE.update;\n\n/**\n * @type {import(\"core\").UseId}\n */\nexport const useId = () => useHook(() => SCOPE.id + \"-\" + SCOPE.i);\n\n/**\n * @type {import(\"internal/hooks\").CreateHooks}\n */\nexport const createHooks = (update, host, id = 0) => {\n    /**\n     * @type {import(\"internal/hooks\").Hooks}\n     **/\n    let hooks = {};\n\n    /**\n     * announces that the updates have finished allowing the\n     * execution of the collectors\n     * @param {import(\"internal/hooks\").Hook[\"tag\"]} tag\n     * @param {boolean} [unmounted]\n     */\n    function cleanEffectsByType(tag, unmounted) {\n        for (const index in hooks) {\n            const hook = hooks[index];\n            if (hook.effect && hook.tag === tag) {\n                hook.value = hook.effect(hook.value, unmounted);\n            }\n        }\n    }\n    /**\n     * @type {import(\"internal/hooks\").Load}\n     */\n    function load(callback) {\n        SCOPE = { host, hooks, update, i: 0, id };\n        let value;\n        try {\n            value = callback();\n        } catch (e) {\n            if (e !== IdSuspense) throw e;\n        } finally {\n            SCOPE = null;\n        }\n        return value;\n    }\n\n    /**\n     * @type {import(\"internal/hooks\").CleanEffects}\n     */\n    const cleanEffects = (unmounted) => {\n        cleanEffectsByType(IdInsertionEffect, unmounted);\n        return () => {\n            cleanEffectsByType(IdLayoutEffect, unmounted);\n            return () => {\n                cleanEffectsByType(IdEffect, unmounted);\n                if (unmounted) hooks = {};\n            };\n        };\n    };\n\n    return { load, cleanEffects };\n};\n","import { setPrototype, transformValue } from \"./set-prototype.js\";\r\nimport { createHooks } from \"../hooks/create-hooks.js\";\r\nexport { Any } from \"./set-prototype.js\";\r\nimport { flat, isHydrate } from \"../utils.js\";\r\nimport { ParseError } from \"./errors.js\";\r\n\r\nlet ID = 0;\r\n/**\r\n *\r\n * @param {Element & {dataset?:object}} node\r\n * @returns {string|number}\r\n */\r\nconst getHydrateId = (node) => {\r\n    const id = (node?.dataset || {})?.hydrate || \"\";\r\n    if (id) {\r\n        return id;\r\n    } else {\r\n        return \"c\" + ID++;\r\n    }\r\n};\r\n\r\n/**\r\n * @type {import(\"component\").C}\r\n */\r\nexport const c = (component, base) => {\r\n    /**\r\n     * @type {import(\"./set-prototype\").Attrs}\r\n     */\r\n    const attrs = {};\r\n    /**\r\n     * @type {import(\"./set-prototype\").Values}\r\n     */\r\n    const values = {};\r\n\r\n    const { props, styles, name } = component;\r\n\r\n    const className = (name[0] || \"\").toUpperCase() + name.slice(1);\r\n    /**\r\n     * @todo Discover a more aesthetic solution at the type level\r\n     * TS tries to set local class rules, these should be ignored\r\n     * @type {any}\r\n     */\r\n    const ctx = {\r\n        [className]: class extends (base || HTMLElement) {\r\n            constructor() {\r\n                super();\r\n                this._setup();\r\n                this._render = () => component({ ...this._props });\r\n                for (const prop in values) this[prop] = values[prop];\r\n            }\r\n            /**\r\n             * @returns {import(\"core\").Sheets}\r\n             */\r\n            static get styles() {\r\n                //@ts-ignore\r\n                return [super.styles, styles];\r\n            }\r\n            async _setup() {\r\n                // _setup only continues if _props has not been defined\r\n                if (this._props) return;\r\n\r\n                this._props = {};\r\n\r\n                /**\r\n                 * @type {Node}\r\n                 */\r\n                let lastParentMount;\r\n\r\n                /**\r\n                 * @type {Node}\r\n                 */\r\n                let lastParentUnmount;\r\n\r\n                this.mounted = new Promise(\r\n                    (resolve) =>\r\n                        (this.mount = () => {\r\n                            resolve();\r\n                            if (lastParentMount != this.parentNode) {\r\n                                this.update();\r\n                                lastParentMount = this.parentNode;\r\n                            }\r\n                        })\r\n                );\r\n\r\n                this.unmounted = new Promise(\r\n                    (resolve) =>\r\n                        (this.unmount = () => {\r\n                            resolve();\r\n                            /**\r\n                             * to recycle the node, its cycle must be closed and\r\n                             * the cycle depends on the parent to preserve the\r\n                             * state in case the nodes move within the same\r\n                             * parent as a result of the use of keys\r\n                             */\r\n                            lastParentUnmount =\r\n                                lastParentUnmount || lastParentMount;\r\n                            if (\r\n                                lastParentUnmount != lastParentMount ||\r\n                                !this.isConnected\r\n                            ) {\r\n                                hooks.cleanEffects(true)()();\r\n                                lastParentUnmount = lastParentMount;\r\n                            }\r\n                        })\r\n                );\r\n\r\n                this.symbolId = this.symbolId || Symbol();\r\n\r\n                const hooks = createHooks(\r\n                    () => this.update(),\r\n                    this,\r\n                    getHydrateId(this)\r\n                );\r\n\r\n                let prevent;\r\n\r\n                let firstRender = true;\r\n\r\n                // some DOM emulators don't define dataset\r\n                const hydrate = isHydrate(this);\r\n\r\n                this.update = () => {\r\n                    if (!prevent) {\r\n                        prevent = true;\r\n\r\n                        /**\r\n                         * this.updated is defined at the runtime of the render,\r\n                         * if it fails it is caught by mistake to unlock prevent\r\n                         */\r\n                        this.updated = (this.updated || this.mounted)\r\n                            .then(() => {\r\n                                try {\r\n                                    const result = hooks.load(this._render);\r\n\r\n                                    const cleanUseLayoutEffects =\r\n                                        hooks.cleanEffects();\r\n\r\n                                    result &&\r\n                                        result.render(\r\n                                            this,\r\n                                            this.symbolId,\r\n                                            hydrate\r\n                                        );\r\n\r\n                                    prevent = false;\r\n\r\n                                    if (firstRender) {\r\n                                        firstRender = false;\r\n                                        // @ts-ignore\r\n                                        !hydrate && applyStyles(this);\r\n                                    }\r\n\r\n                                    return cleanUseLayoutEffects();\r\n                                } finally {\r\n                                    // Remove lock in case of synchronous error\r\n                                    prevent = false;\r\n                                }\r\n                            })\r\n                            .then(\r\n                                /**\r\n                                 * @param {import(\"internal/hooks\").CleanUseEffects} [cleanUseEffect]\r\n                                 */\r\n                                (cleanUseEffect) => {\r\n                                    cleanUseEffect && cleanUseEffect();\r\n                                }\r\n                            );\r\n                    }\r\n\r\n                    return this.updated;\r\n                };\r\n\r\n                this.update();\r\n            }\r\n            connectedCallback() {\r\n                this.mount();\r\n                //@ts-ignore\r\n                super.connectedCallback && super.connectedCallback();\r\n            }\r\n            async disconnectedCallback() {\r\n                //@ts-ignore\r\n                super.disconnectedCallback && super.disconnectedCallback();\r\n                // The webcomponent will only resolve disconnected if it is\r\n                // actually disconnected of the document, otherwise it will keep the record.\r\n\r\n                await this.mounted;\r\n\r\n                this.unmount();\r\n            }\r\n            /**\r\n             * @this {import(\"dom\").AtomicoThisInternal}\r\n             * @param {string} attr\r\n             * @param {(string|null)} oldValue\r\n             * @param {(string|null)} value\r\n             */\r\n            attributeChangedCallback(attr, oldValue, value) {\r\n                if (attrs[attr]) {\r\n                    // _ignoreAttr exists temporarily\r\n                    // @ts-ignore\r\n                    if (attr === this._ignoreAttr || oldValue === value) return;\r\n                    // Choose the property name to send the update\r\n                    const { prop, type } = attrs[attr];\r\n                    // The following error cannot be caught\r\n                    try {\r\n                        this[prop] = transformValue(type, value);\r\n                    } catch (e) {\r\n                        throw new ParseError(\r\n                            this,\r\n                            `The value defined as attr '${attr}' cannot be parsed by type '${type.name}'`,\r\n                            value\r\n                        );\r\n                    }\r\n                } else {\r\n                    // If the attribute does not exist in the scope attrs, the event is sent to super\r\n                    // @ts-ignore\r\n                    super.attributeChangedCallback(attr, oldValue, value);\r\n                }\r\n            }\r\n\r\n            static get props() {\r\n                //@ts-ignore\r\n                return { ...super.props, ...props };\r\n            }\r\n\r\n            static get observedAttributes() {\r\n                // See if there is an observedAttributes declaration to match with the current one\r\n                // @ts-ignore\r\n                const superAttrs = super.observedAttributes || [];\r\n                for (const prop in props) {\r\n                    setPrototype(\r\n                        this.prototype,\r\n                        prop,\r\n                        props[prop],\r\n                        attrs,\r\n                        values\r\n                    );\r\n                }\r\n                return Object.keys(attrs).concat(superAttrs);\r\n            }\r\n        },\r\n    };\r\n\r\n    return ctx[className];\r\n};\r\n\r\n/**\r\n * Attach the css to the shadowDom\r\n * @param {import(\"dom\").AtomicoThisInternal} host\r\n */\r\nfunction applyStyles(host) {\r\n    const { styles } = host.constructor;\r\n    const { shadowRoot } = host;\r\n    if (shadowRoot && styles.length) {\r\n        /**\r\n         * @type {CSSStyleSheet[]}\r\n         */\r\n        const sheets = [];\r\n        flat(styles, (value) => {\r\n            if (value) {\r\n                if (value instanceof Element) {\r\n                    shadowRoot.appendChild(value.cloneNode(true));\r\n                } else {\r\n                    sheets.push(value);\r\n                }\r\n            }\r\n        });\r\n        if (sheets.length) shadowRoot.adoptedStyleSheets = sheets;\r\n    }\r\n}\r\n","import {\n    useHook,\n    IdLayoutEffect,\n    IdEffect,\n    IdInsertionEffect,\n} from \"./create-hooks.js\";\nimport { isEqualArray, isFunction } from \"../utils.js\";\n\n/**\n * useLayoutEffect and useEffect have a similar algorithm\n * in that the position of the callback varies.\n * @param {IdLayoutEffect|IdEffect|IdInsertionEffect} type\n * @return {import(\"internal/hooks\").UseAnyEffect}\n */\nconst createEffect = (type) => (currentEffect, currentArgs) => {\n    useHook(\n        /**\n         * Clean the effect hook\n         * @type {import(\"internal/hooks\").CollectorEffect}\n         */\n\n        ([collector, args] = []) => {\n            if (args || !args) {\n                if (args && isEqualArray(args, currentArgs)) {\n                    collector = collector || true;\n                } else {\n                    // TS does not infer the following conditional\n                    // @ts-ignore\n                    isFunction(collector) && collector();\n                    collector = null;\n                }\n            }\n            return [collector, currentArgs];\n        },\n        /**\n         * @returns {any}\n         */\n        ([collector, args], unmounted) => {\n            if (unmounted) {\n                // ts does not infer the following conditional\n                isFunction(collector) && collector();\n                return [];\n            } else {\n                return [collector ? collector : currentEffect(), args];\n            }\n        },\n        type\n    );\n};\n\nexport const useLayoutEffect = createEffect(IdLayoutEffect);\n\nexport const useEffect = createEffect(IdEffect);\n\nexport const useInsertionEffect = createEffect(IdInsertionEffect);\n","/**\n * @type {import(\"core\").Options}\n */\nexport const options = {\n    //@ts-ignore\n    sheet: !!document.adoptedStyleSheets,\n};\n","import { isFunction, isObject, isArray, flat, isHydrate } from \"./utils.js\";\nimport { options } from \"./options.js\";\n// Object used to know which properties are extracted directly\n// from the node to verify 2 if they have changed\nconst VAL_FROM_PROPS = {\n    checked: 1,\n    value: 1,\n    selected: 1,\n};\n// Map of attributes that escape the property analysis\nconst PROPS_AS_ATTRS = {\n    list: 1,\n    type: 1,\n    size: 1,\n    form: 1,\n    width: 1,\n    height: 1,\n    src: 1,\n    href: 1,\n    slot: 1,\n};\n// escapes from diffProps compare process\nconst INTERNAL_PROPS = {\n    shadowDom: 1,\n    staticNode: 1,\n    cloneNode: 1,\n    children: 1,\n    key: 1,\n};\n// Immutable for comparison of empty properties\nconst EMPTY_PROPS = {};\n// Immutable for empty children comparison\nconst EMPTY_CHILDREN = [];\n// Alias for document\nexport const $ = document;\n// Fragment marker\nexport class Mark extends Text {}\n\nconst SymbolFor = Symbol.for;\n// Default ID used to store the Vnode state\nexport const ID = SymbolFor(\"Atomico.ID\");\n// Internal marker to know if the Vnode comes from Atomico\nexport const $$ = SymbolFor(\"Atomico.$$\");\n\nexport const REF = SymbolFor(\"Atomico.REF\");\n\nexport const Fragment = () => {};\n\n/**\n * @todo use the vnode.render property as a replacement for vnode.$$\n * @param {Element} node\n * @param {import(\"vnode\").RenderId} [id]\n * @param {boolean} [hydrate]\n * @return {ChildNode}\n */\nexport function RENDER(node, id, hydrate) {\n    return diff(this, node, id, hydrate);\n}\n/**\n * @type {import(\"vnode\").H}\n */\nexport const h = (type, p, ...args) => {\n    /**\n     * @type {any}\n     */\n    const props = p || EMPTY_PROPS;\n\n    let { children } = props;\n\n    children =\n        children != null ? children : args.length ? args : EMPTY_CHILDREN;\n\n    if (type === Fragment) {\n        //@ts-ignore\n        return children;\n    }\n\n    const raw = type\n        ? type instanceof Node\n            ? 1\n            : //@ts-ignore\n              type.prototype instanceof HTMLElement && 2\n        : 0;\n\n    //@ts-ignore\n    if (raw === false && type instanceof Function) {\n        return type(\n            children != EMPTY_CHILDREN ? { children, ...props } : props\n        );\n    }\n\n    /**\n     * @todo look for a more elegant type, since you can't follow the type rules without capturing this\n     * @type {any}\n     */\n    const render = options.render || RENDER;\n\n    /**\n     * @type {import(\"vnode\").VNodeAny}\n     */\n    const vnode = {\n        $$,\n        type,\n        props,\n        children,\n        key: props.key,\n        // key for lists by keys\n        // define if the node declares its shadowDom\n        shadow: props.shadowDom,\n        // allows renderings to run only once\n        static: props.staticNode,\n        // defines whether the type is a childNode `1` or a constructor `2`\n        raw,\n        // defines whether to use the second parameter for document.createElement\n        is: props.is,\n        // clone the node if it comes from a reference\n        clone: props.cloneNode,\n        render,\n    };\n\n    //@ts-ignore\n    return vnode;\n};\n\n/**\n * Create or update a node\n * Node: The declaration of types through JSDOC does not allow to compress\n * the exploration of the parameters\n * @param {ReturnType<h>} newVnode\n * @param {Element} node\n * @param {import(\"vnode\").RenderId} [id]\n * @param {boolean} [hydrate]\n * @param {boolean} [isSvg]\n * @returns {ChildNode}\n */\nfunction diff(newVnode, node, id = ID, hydrate, isSvg) {\n    let isNewNode;\n    // If the node maintains the source vnode it escapes from the update tree\n    if ((node && node[id] && node[id].vnode == newVnode) || newVnode.$$ != $$)\n        return node;\n    // The process only continues when you may need to create a node\n    if (newVnode || !node) {\n        isSvg = isSvg || newVnode.type == \"svg\";\n        // determines if the node should be regenerated\n        isNewNode =\n            newVnode.type != \"host\" &&\n            (newVnode.raw == 1\n                ? (node && newVnode.clone ? node[REF] : node) != newVnode.type\n                : newVnode.raw == 2\n                ? !(node instanceof newVnode.type)\n                : node\n                ? node[REF] || node.localName != newVnode.type\n                : !node);\n\n        if (isNewNode && newVnode.type != null) {\n            if (newVnode.raw == 1 && newVnode.clone) {\n                hydrate = true;\n                node = newVnode.type.cloneNode(true);\n                node[REF] = newVnode.type;\n            } else {\n                node =\n                    newVnode.raw == 1\n                        ? newVnode.type\n                        : newVnode.raw == 2\n                        ? new newVnode.type()\n                        : isSvg\n                        ? $.createElementNS(\n                              \"http://www.w3.org/2000/svg\",\n                              newVnode.type\n                          )\n                        : $.createElement(\n                              newVnode.type,\n                              newVnode.is ? { is: newVnode.is } : undefined\n                          );\n            }\n        }\n    }\n\n    const oldVNodeStore = node[id] ? node[id] : EMPTY_PROPS;\n\n    /**\n     * @type {import(\"vnode\").VNodeStore}\n     */\n    const { vnode = EMPTY_PROPS, cycle = 0 } = oldVNodeStore;\n\n    let { fragment, handlers } = oldVNodeStore;\n\n    /**\n     * @type {import(\"vnode\").VNodeGeneric}\n     */\n    const { children = EMPTY_CHILDREN, props = EMPTY_PROPS } = vnode;\n\n    /**\n     * @type {import(\"vnode\").Handlers}\n     */\n    handlers = isNewNode ? {} : handlers || {};\n    /**\n     * Escape a second render if the vnode.type is equal\n     */\n    if (newVnode.static && !isNewNode) return node;\n\n    newVnode.shadow && !node.shadowRoot && node.attachShadow({ mode: \"open\" });\n\n    newVnode.props != props &&\n        diffProps(node, props, newVnode.props, handlers, isSvg);\n\n    if (newVnode.children !== children) {\n        const nextParent = newVnode.shadow ? node.shadowRoot : node;\n\n        fragment = renderChildren(\n            newVnode.children,\n            /**\n             * @todo for hydration use attribute and send childNodes\n             */\n            fragment,\n            nextParent,\n            id,\n            // add support to foreignObject, children will escape from svg\n            !cycle && hydrate,\n            isSvg && newVnode.type == \"foreignObject\" ? false : isSvg\n        );\n    }\n\n    node[id] = { vnode: newVnode, handlers, fragment, cycle: cycle + 1 };\n\n    return node;\n}\n/**\n *\n * @param {Element|ShadowRoot} parent\n * @param {boolean} [hydrate]\n * @return {import(\"vnode\").Fragment}\n */\nfunction createFragment(parent, hydrate) {\n    const markStart = new Mark(\"\");\n    const markEnd = new Mark(\"\");\n\n    /**\n     * @type {Element}\n     */\n    let node;\n\n    parent[hydrate ? \"prepend\" : \"append\"](markStart);\n\n    if (hydrate) {\n        let { firstElementChild } = parent;\n        while (firstElementChild) {\n            if (isHydrate(firstElementChild)) {\n                node = firstElementChild;\n                break;\n            }\n            firstElementChild = firstElementChild.nextElementSibling;\n        }\n    }\n\n    if (node) {\n        parent.insertBefore(markEnd, node);\n    } else {\n        parent.append(markEnd);\n    }\n\n    return {\n        markStart,\n        markEnd,\n    };\n}\n\n/**\n * This method should only be executed from render,\n * it allows rendering the children of the virtual-dom\n * @param {any} children\n * @param {import(\"vnode\").Fragment} fragment\n * @param {Element|ShadowRoot} parent\n * @param {any} id\n * @param {boolean} [hydrate]\n * @param {boolean} [isSvg]\n */\nexport function renderChildren(children, fragment, parent, id, hydrate, isSvg) {\n    children =\n        children == null ? null : isArray(children) ? children : [children];\n\n    const nextFragment = fragment || createFragment(parent, hydrate);\n\n    const { markStart, markEnd, keyes } = nextFragment;\n    /**\n     * @type {import(\"vnode\").Keyes}\n     */\n    let nextKeyes;\n    /**\n     * Eliminate intermediate nodes that are not used in the process in keyed\n     * @type {Set<ChildNode>}\n     */\n    const removeNodes = keyes && new Set();\n\n    /**\n     * RULES: that you should never exceed \"c\"\n     * @type {ChildNode}\n     */\n    let currentNode = markStart;\n\n    children &&\n        flat(children, (child) => {\n            if (typeof child == \"object\" && child.$$ != $$) {\n                return;\n            }\n\n            const key = child.$$ && child.key;\n            const childKey = keyes && key != null && keyes.get(key);\n            // check if the displacement affected the index of the child with\n            // assignment of key, if so the use of nextSibling is prevented\n            if (currentNode != markEnd && currentNode === childKey) {\n                removeNodes.delete(currentNode);\n            } else {\n                currentNode =\n                    currentNode == markEnd ? markEnd : currentNode.nextSibling;\n            }\n\n            const childNode = keyes ? childKey : currentNode;\n\n            let nextChildNode = childNode;\n            // text node diff\n            if (!child.$$) {\n                const text = child + \"\";\n                if (\n                    !(nextChildNode instanceof Text) ||\n                    nextChildNode instanceof Mark\n                ) {\n                    nextChildNode = new Text(text);\n                }\n                // Only one Text node falls in this block\n                // @ts-ignore\n                else if (nextChildNode.data != text) {\n                    // @ts-ignore\n                    nextChildNode.data = text;\n                }\n            } else {\n                // diff only resive Elements\n                // @ts-ignore\n                nextChildNode = diff(child, childNode, id, hydrate, isSvg);\n            }\n            if (nextChildNode != currentNode) {\n                keyes && removeNodes.delete(nextChildNode);\n                if (!childNode || keyes) {\n                    parent.insertBefore(nextChildNode, currentNode);\n\n                    keyes &&\n                        currentNode != markEnd &&\n                        removeNodes.add(currentNode);\n                } else if (childNode == markEnd) {\n                    parent.insertBefore(nextChildNode, markEnd);\n                } else {\n                    parent.replaceChild(nextChildNode, childNode);\n                    currentNode = nextChildNode;\n                }\n            }\n            // if there is a key, a map of keys is created\n            if (key != null) {\n                nextKeyes = nextKeyes || new Map();\n                nextKeyes.set(key, nextChildNode);\n            }\n        });\n\n    currentNode = currentNode == markEnd ? markEnd : currentNode.nextSibling;\n\n    if (fragment && currentNode != markEnd) {\n        // cleaning of remnants within the fragment\n        while (currentNode != markEnd) {\n            const nodeToRemove = currentNode;\n            currentNode = currentNode.nextSibling;\n            nodeToRemove.remove();\n        }\n    }\n\n    removeNodes && removeNodes.forEach((node) => node.remove());\n\n    nextFragment.keyes = nextKeyes;\n\n    return nextFragment;\n}\n\n/**\n *\n * @param {Element} node\n * @param {Object} props\n * @param {Object} nextProps\n * @param {boolean} isSvg\n * @param {import(\"vnode\").Handlers} handlers\n **/\nexport function diffProps(node, props, nextProps, handlers, isSvg) {\n    for (const key in props) {\n        !(key in nextProps) &&\n            setProperty(node, key, props[key], null, isSvg, handlers);\n    }\n    for (const key in nextProps) {\n        setProperty(node, key, props[key], nextProps[key], isSvg, handlers);\n    }\n}\n\n/**\n *\n * @param {Element} node\n * @param {string} key\n * @param {any} prevValue\n * @param {any} nextValue\n * @param {boolean} isSvg\n * @param {import(\"vnode\").Handlers} handlers\n */\nexport function setProperty(node, key, prevValue, nextValue, isSvg, handlers) {\n    key = key == \"class\" && !isSvg ? \"className\" : key;\n    // define empty value\n    prevValue = prevValue == null ? null : prevValue;\n    nextValue = nextValue == null ? null : nextValue;\n\n    if (key in node && VAL_FROM_PROPS[key]) {\n        prevValue = node[key];\n    }\n\n    if (nextValue === prevValue || INTERNAL_PROPS[key] || key[0] == \"_\") return;\n\n    if (\n        key[0] == \"o\" &&\n        key[1] == \"n\" &&\n        (isFunction(nextValue) || isFunction(prevValue))\n    ) {\n        setEvent(node, key.slice(2), nextValue, handlers);\n    } else if (key == \"ref\") {\n        if (nextValue) {\n            if (isFunction(nextValue)) {\n                nextValue(node);\n            } else {\n                nextValue.current = node;\n            }\n        }\n    } else if (key == \"style\") {\n        /**\n         * @todo Find out why Element defines style at the type level\n         * @type {any}\n         */\n        const { style } = node;\n\n        prevValue = prevValue || \"\";\n        nextValue = nextValue || \"\";\n\n        const prevIsObject = isObject(prevValue);\n        const nextIsObject = isObject(nextValue);\n\n        if (prevIsObject) {\n            for (const key in prevValue) {\n                if (nextIsObject) {\n                    !(key in nextValue) && setPropertyStyle(style, key, null);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        if (nextIsObject) {\n            for (const key in nextValue) {\n                const value = nextValue[key];\n                if (prevIsObject && prevValue[key] === value) continue;\n                setPropertyStyle(style, key, value);\n            }\n        } else {\n            style.cssText = nextValue;\n        }\n    } else {\n        const attr = key[0] == \"$\" ? key.slice(1) : key;\n        if (\n            attr === key &&\n            ((!isSvg && !PROPS_AS_ATTRS[key] && key in node) ||\n                isFunction(nextValue) ||\n                isFunction(prevValue))\n        ) {\n            node[key] = nextValue == null ? \"\" : nextValue;\n        } else if (nextValue == null) {\n            node.removeAttribute(attr);\n        } else {\n            node.setAttribute(\n                attr,\n                isObject(nextValue) ? JSON.stringify(nextValue) : nextValue\n            );\n        }\n    }\n}\n\n/**\n *\n * @param {Node} node\n * @param {string} type\n * @param {import(\"vnode\").VNodeListener} [nextHandler]\n * @param {import(\"vnode\").Handlers} [handlers]\n */\nexport function setEvent(node, type, nextHandler, handlers) {\n    // add handleEvent to handlers\n    if (!handlers.handleEvent) {\n        /**\n         * {@link https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler}\n         **/\n        handlers.handleEvent = (event) =>\n            handlers[event.type].call(node, event);\n    }\n    if (nextHandler) {\n        // create the subscriber if it does not exist\n        if (!handlers[type]) {\n            //the event configuration is only subscribed at the time of association\n            const options =\n                nextHandler.capture || nextHandler.once || nextHandler.passive\n                    ? Object.assign({}, nextHandler)\n                    : null;\n            node.addEventListener(type, handlers, options);\n        }\n        // update the associated event\n        handlers[type] = nextHandler;\n    } else {\n        // \tdelete the associated event\n        if (handlers[type]) {\n            node.removeEventListener(type, handlers);\n            delete handlers[type];\n        }\n    }\n}\n/**\n *\n * @param {*} style\n * @param {string} key\n * @param {string} value\n */\nexport function setPropertyStyle(style, key, value) {\n    let method = \"setProperty\";\n    if (value == null) {\n        method = \"removeProperty\";\n        value = null;\n    }\n    if (~key.indexOf(\"-\")) {\n        style[method](key, value);\n    } else {\n        style[key] = value;\n    }\n}\n\nexport { diff as render };\n","import { addons } from \"@storybook/addons\";\nimport { SNIPPET_RENDERED } from \"@storybook/docs-tools\";\nimport { c, h, useEffect, useHost } from \"atomico\";\nconst Alias = {\n    tsx: \"typescript\",\n    html: \"html\",\n};\nfunction wrapper({ story, cid, args, code, source }) {\n    const host = useHost();\n    useEffect(() => {\n        requestAnimationFrame(() => {\n            addons.getChannel().emit(SNIPPET_RENDERED, {\n                id: cid,\n                args,\n                source: source === \"html\" ? host.current.innerHTML : code,\n                ...(Alias[source] ? { format: Alias[source] } : null),\n            });\n        });\n    });\n    const result = story();\n    host.result = result;\n    return h(\"host\", null, result);\n}\nwrapper.props = {\n    cid: String,\n    story: Function,\n    originalSource: String,\n    code: String,\n    source: String,\n    args: null,\n};\nconst Wrapper = c(wrapper);\nif (!customElements.get(\"atomico-decorator-wrapper\"))\n    customElements.define(\"atomico-decorator-wrapper\", Wrapper);\nexport const decorator = ({ source } = { source: \"code\" }) => (Story, context) => {\n    const cache = context.canvasElement;\n    if (!cache[context.id]) {\n        cache[context.id] = document.createElement(\"atomico-decorator-wrapper\");\n        cache[context.id].setAttribute(\"cid\", context.id);\n    }\n    const host = cache[context.id];\n    host.story = Story;\n    host.args = context.unmappedArgs;\n    host.code = context.parameters.docs.source.originalSource;\n    host.source = source;\n    const test = context.parameters.fileName.match(/\\.(\\w+)$/);\n    if (test) {\n        context.parameters.docs.source.language = test.at(1);\n    }\n    return host;\n};\n"],"names":["isEqualArray","before","after","length","i","isFunction","value","isObject","isArray","isHydrate","node","flat","list","callback","last","reduce","type","Error","target","message","PropError","ParseError","Any","TRUE_VALUES","setPrototype","prototype","prop","schema","attrs","values","reflect","event","attr","getAttr","isCallable","newValue","oldValue","error","filterValue","dispatchEvent","reflectValue","base","eventInit","host","transformValue","SCOPE","IdSuspense","IdEffect","IdLayoutEffect","IdInsertionEffect","useHook","render","effect","tag","hooks","hook","useHost","ref","useUpdate","createHooks","update","id","cleanEffectsByType","unmounted","index","load","e","ID","getHydrateId","_a","c","component","props","styles","name","className","lastParentMount","lastParentUnmount","resolve","prevent","firstRender","hydrate","result","cleanUseLayoutEffects","applyStyles","cleanUseEffect","superAttrs","shadowRoot","sheets","createEffect","currentEffect","currentArgs","collector","args","useLayoutEffect","useEffect","options","VAL_FROM_PROPS","PROPS_AS_ATTRS","INTERNAL_PROPS","EMPTY_PROPS","EMPTY_CHILDREN","$","Mark","SymbolFor","$$","REF","Fragment","RENDER","diff","h","p","children","raw","newVnode","isSvg","isNewNode","oldVNodeStore","vnode","cycle","fragment","handlers","diffProps","nextParent","renderChildren","createFragment","parent","markStart","markEnd","firstElementChild","nextFragment","keyes","nextKeyes","removeNodes","currentNode","child","key","childKey","childNode","nextChildNode","text","nodeToRemove","nextProps","setProperty","prevValue","nextValue","setEvent","style","prevIsObject","nextIsObject","setPropertyStyle","nextHandler","method","addons","Alias","wrapper","story","cid","code","source","SNIPPET_RENDERED","Wrapper","decorator","Story","context","cache","test"],"mappings":"wCAYO,SAASA,EAAaC,EAAQC,EAAO,CACxC,MAAMC,EAASF,EAAO,OACtB,GAAIE,IAAWD,EAAM,OAAQ,MAAO,GACpC,QAASE,EAAI,EAAGA,EAAID,EAAQC,IACxB,GAAIH,EAAOG,CAAC,IAAMF,EAAME,CAAC,EAAG,MAAO,GAEvC,MAAO,EACX,CAKY,MAACC,EAAcC,GAAU,OAAOA,GAAS,WAMxCC,EAAYD,GAAU,OAAOA,GAAS,SAEtC,CAAE,QAAAE,CAAS,EAAG,MAOdC,EAAaC,GAAS,aAAcA,GAAA,YAAAA,EAAM,UAAW,CAAA,GAO3D,SAASC,EAAKC,EAAMC,EAAU,CACjC,IAAIC,EAIJ,MAAMC,EAAUH,GAAS,CACrB,GAAI,CAAE,OAAAT,CAAQ,EAAGS,EACjB,QAASR,EAAI,EAAGA,EAAID,EAAQC,IAAK,CAC7B,MAAME,EAAQM,EAAKR,CAAC,EACpB,GAAIE,GAAS,MAAM,QAAQA,CAAK,EAC5BS,EAAOT,CAAK,MACT,CACH,MAAMU,EAAO,OAAOV,EACpB,GACIA,GAAS,MACTU,IAAS,YACTA,IAAS,UAET,SACOA,IAAS,UAAYA,IAAS,UACjCF,GAAQ,OAAMA,EAAO,IACzBA,GAAQR,IAEJQ,GAAQ,OACRD,EAASC,CAAI,EACbA,EAAO,MAEXD,EAASP,CAAK,EAErB,CACJ,CACT,EAEIS,EAAOH,CAAI,EAEPE,GAAQ,MAAMD,EAASC,CAAI,CACnC,CClFO,MAAMG,CAAM,CAOf,YAAYC,EAAQC,EAASb,EAAO,CAChC,KAAK,QAAUa,EACf,KAAK,OAASD,EACd,KAAK,MAAQZ,CAChB,CACL,CAEO,MAAMc,UAAkBH,CAAM,CAAE,CAEhC,MAAMI,UAAmBJ,CAAM,CAAA,CCV/B,MAAMK,EAAM,KAKbC,EAAc,CAAE,KAAM,EAAG,GAAI,EAAG,EAAG,GAWlC,SAASC,EAAaC,EAAWC,EAAMC,EAAQC,EAAOC,EAAQ,CAEjE,KAAM,CACF,KAAAb,EACA,QAAAc,EACA,MAAAC,EACA,MAAAzB,EACA,KAAA0B,EAAOC,EAAQP,CAAI,CAC3B,EAAQnB,EAASoB,CAAM,GAAKA,GAAUL,EAAMK,EAAS,CAAE,KAAMA,GAEnDO,EAAa,EAAElB,GAAQ,UAAYA,GAAQM,GAEjD,OAAO,eAAeG,EAAWC,EAAM,CACnC,aAAc,GAKd,IAAIS,EAAU,CACV,MAAMC,EAAW,KAAKV,CAAI,EACpB,CAAE,MAAAW,EAAO,MAAA/B,CAAK,EAAKgC,EACrBtB,EACAkB,GAAc7B,EAAW8B,CAAQ,EAC3BA,EAASC,CAAQ,EACjBD,CACtB,EACY,GAAIE,GAAS/B,GAAS,KAClB,MAAM,IAAIc,EACN,KACA,+BAA+BM,CAAI,sBAAsBV,EAAK,IAAI,IAClEV,CACpB,EAGgB8B,GAAY9B,IAEhB,KAAK,OAAOoB,CAAI,EAAIpB,GAAgB,OAEpC,KAAK,OAAM,EAIXyB,GAASQ,EAAc,KAAMR,CAAK,EAIlC,KAAK,QAAQ,KAAK,IAAM,CAChBD,IACA,KAAK,YAAcE,EACnBQ,EAAa,KAAMxB,EAAMgB,EAAM,KAAKN,CAAI,CAAC,EACzC,KAAK,YAAc,KAEvC,CAAa,EACJ,EAID,KAAM,CACF,OAAO,KAAK,OAAOA,CAAI,CAC1B,CACT,CAAK,EAEGpB,GAAS,OAAMuB,EAAOH,CAAI,EAAIpB,GAElCsB,EAAMI,CAAI,EAAI,CAAE,KAAAN,EAAM,KAAAV,CAAI,CAC9B,CAOY,MAACuB,EAAgB,CACzB7B,EACA,CAAE,KAAAM,EAAM,KAAAyB,EAAO,YAAa,GAAGC,CAAW,IACzChC,EAAK,cAAc,IAAI+B,EAAKzB,EAAM0B,CAAS,CAAC,EAOpCT,EAAWP,GAASA,EAAK,QAAQ,WAAY,KAAK,EAAE,cASpDc,EAAe,CAACG,EAAM3B,EAAMgB,EAAM1B,IAC3CA,GAAS,MAASU,GAAQ,SAAW,CAACV,EAChCqC,EAAK,gBAAgBX,CAAI,EACzBW,EAAK,aACDX,EACAzB,EAASD,CAAK,EACR,KAAK,UAAUA,CAAK,EACpBU,GAAQ,QACR,GACAV,CACpB,EAQasC,EAAiB,CAAC5B,EAAMV,IACjCU,GAAQ,QACF,CAAC,CAACO,EAAYjB,CAAK,EACnBU,GAAQ,OACR,OAAOV,CAAK,EACZU,GAAQ,OAASA,GAAQ,OACzB,KAAK,MAAMV,CAAK,EAChBA,EAOGgC,EAAc,CAACtB,EAAMV,IAC9BU,GAAQ,MAAQV,GAAS,KACnB,CAAE,MAAAA,EAAO,MAAO,EAAO,EACvBU,GAAQ,QAAUV,IAAU,GAC5B,CAAE,MAAO,OAAW,MAAO,EAAO,EAClCU,GAAQ,QAAUA,GAAQ,OAASA,GAAQ,OAC3C,CAAE,MAAAV,EAAO,MAAO,CAAE,EAAC,SAAS,KAAKA,CAAK,IAAM,WAAWU,EAAK,IAAI,GAAK,EACrEV,aAAiBU,EACjB,CAAE,MAAAV,EAAO,MAAOU,GAAQ,QAAU,OAAO,MAAMV,EAAM,QAAO,CAAE,CAAG,EACjEU,GAAQ,QAAUA,GAAQ,QAAUA,GAAQ,QAC5C,CACI,MAAAV,EACA,MACIU,GAAQ,OACF,OAAOV,GAAS,SACZ,GACA,OAAO,MAAMA,CAAK,EACtBU,GAAQ,OACR,OAAOV,GAAS,SAChB,OAAOA,GAAS,SAC7B,EACD,CAAE,MAAAA,EAAO,MAAO,ICnK1B,IAAIuC,EAKQ,MAACC,GAAa,OAAS,EAKtBC,EAAW,OAAO,QAAQ,EAK1BC,EAAiB,OAAO,cAAc,EAKtCC,GAAoB,OAAO,iBAAiB,EAK5CC,EAAU,CAACC,EAAQC,EAAQC,IAAQ,CAC5C,KAAM,CAAE,EAAAjD,EAAG,MAAAkD,CAAO,EAAGT,EAEfU,EAAQD,EAAMlD,CAAC,EAAIkD,EAAMlD,CAAC,GAAK,CAAA,EAErC,OAAAmD,EAAK,MAAQJ,EAAOI,EAAK,KAAK,EAC9BA,EAAK,OAASH,EACdG,EAAK,IAAMF,EAEXR,EAAM,IAECS,EAAMlD,CAAC,EAAE,KACpB,EAWaoD,GAAU,IAAMN,EAAQ,CAACO,EAAM,CAAE,QAASZ,EAAM,IAAM,IAAKY,CAAG,EAM9DC,GAAY,IAAMb,EAAM,OAUxBc,GAAc,CAACC,EAAQjB,EAAMkB,EAAK,IAAM,CAIjD,IAAIP,EAAQ,CAAA,EAQZ,SAASQ,EAAmBT,EAAKU,EAAW,CACxC,UAAWC,KAASV,EAAO,CACvB,MAAMC,EAAOD,EAAMU,CAAK,EACpBT,EAAK,QAAUA,EAAK,MAAQF,IAC5BE,EAAK,MAAQA,EAAK,OAAOA,EAAK,MAAOQ,CAAS,EAErD,CACJ,CAID,SAASE,EAAKpD,EAAU,CACpBgC,EAAQ,CAAE,KAAAF,EAAM,MAAAW,EAAO,OAAAM,EAAQ,EAAG,EAAG,GAAAC,GACrC,IAAIvD,EACJ,GAAI,CACAA,EAAQO,EAAQ,CACnB,OAAQqD,EAAG,CACR,GAAIA,IAAMpB,GAAY,MAAMoB,CACxC,QAAkB,CACNrB,EAAQ,IACX,CACD,OAAOvC,CACV,CAgBD,MAAO,CAAE,KAAA2D,EAAM,aAXOF,IAClBD,EAAmBb,GAAmBc,CAAS,EACxC,KACHD,EAAmBd,EAAgBe,CAAS,EACrC,IAAM,CACTD,EAAmBf,EAAUgB,CAAS,EAClCA,IAAWT,EAAQ,GACvC,IAKA,EChHA,IAAIa,GAAK,EAMT,MAAMC,GAAgB1D,GAAS,OAC3B,MAAMmD,IAAMQ,GAAA3D,GAAA,YAAAA,EAAM,UAAW,CAAE,IAAnB,YAAA2D,EAAsB,UAAW,GAC7C,OAAIR,GAGO,IAAMM,IAErB,EAKaG,GAAI,CAACC,EAAW9B,IAAS,CAIlC,MAAMb,EAAQ,CAAA,EAIRC,EAAS,CAAA,EAET,CAAE,MAAA2C,EAAO,OAAAC,EAAQ,KAAAC,CAAI,EAAKH,EAE1BI,GAAaD,EAAK,CAAC,GAAK,IAAI,YAAW,EAAKA,EAAK,MAAM,CAAC,EA6M9D,MAvMY,CACR,CAACC,CAAS,EAAG,cAAelC,GAAQ,YAAa,CAC7C,aAAc,CACV,QACA,KAAK,OAAM,EACX,KAAK,QAAU,IAAM8B,EAAU,CAAE,GAAG,KAAK,MAAM,CAAE,EACjD,UAAW7C,KAAQG,EAAQ,KAAKH,CAAI,EAAIG,EAAOH,CAAI,CACtD,CAID,WAAW,QAAS,CAEhB,MAAO,CAAC,MAAM,OAAQ+C,CAAM,CAC/B,CACD,MAAM,QAAS,CAEX,GAAI,KAAK,OAAQ,OAEjB,KAAK,OAAS,GAKd,IAAIG,EAKAC,EAEJ,KAAK,QAAU,IAAI,QACdC,GACI,KAAK,MAAQ,IAAM,CAChBA,IACIF,GAAmB,KAAK,aACxB,KAAK,OAAM,EACXA,EAAkB,KAAK,WAEvD,CACA,EAEgB,KAAK,UAAY,IAAI,QAChBE,GACI,KAAK,QAAU,IAAM,CAClBA,IAOAD,EACIA,GAAqBD,GAErBC,GAAqBD,GACrB,CAAC,KAAK,eAENtB,EAAM,aAAa,EAAI,EAAC,IACxBuB,EAAoBD,EAEpD,CACA,EAEgB,KAAK,SAAW,KAAK,UAAY,OAAM,EAEvC,MAAMtB,EAAQK,GACV,IAAM,KAAK,OAAQ,EACnB,KACAS,GAAa,IAAI,CACrC,EAEgB,IAAIW,EAEAC,EAAc,GAGlB,MAAMC,EAAUxE,EAAU,IAAI,EAE9B,KAAK,OAAS,KACLsE,IACDA,EAAU,GAMV,KAAK,SAAW,KAAK,SAAW,KAAK,SAChC,KAAK,IAAM,CACR,GAAI,CACA,MAAMG,EAAS5B,EAAM,KAAK,KAAK,OAAO,EAEhC6B,EACF7B,EAAM,aAAY,EAEtB,OAAA4B,GACIA,EAAO,OACH,KACA,KAAK,SACLD,CAC5C,EAEoCF,EAAU,GAENC,IACAA,EAAc,GAEd,CAACC,GAAWG,GAAY,IAAI,GAGzBD,EAAqB,CAChE,QAA0C,CAENJ,EAAU,EACb,CACjC,CAA6B,EACA,KAIIM,GAAmB,CAChBA,GAAkBA,EAAc,CACnC,CACjC,GAG2B,KAAK,SAGhB,KAAK,OAAM,CACd,CACD,mBAAoB,CAChB,KAAK,MAAK,EAEV,MAAM,mBAAqB,MAAM,mBACpC,CACD,MAAM,sBAAuB,CAEzB,MAAM,sBAAwB,MAAM,uBAIpC,MAAM,KAAK,QAEX,KAAK,QAAO,CACf,CAOD,yBAAyBrD,EAAMI,EAAU9B,EAAO,CAC5C,GAAIsB,EAAMI,CAAI,EAAG,CAGb,GAAIA,IAAS,KAAK,aAAeI,IAAa9B,EAAO,OAErD,KAAM,CAAE,KAAAoB,EAAM,KAAAV,CAAM,EAAGY,EAAMI,CAAI,EAEjC,GAAI,CACA,KAAKN,CAAI,EAAIkB,EAAe5B,EAAMV,CAAK,CAC1C,MAAW,CACR,MAAM,IAAIe,EACN,KACA,8BAA8BW,CAAI,+BAA+BhB,EAAK,IAAI,IAC1EV,CAC5B,CACqB,CACrB,MAGoB,MAAM,yBAAyB0B,EAAMI,EAAU9B,CAAK,CAE3D,CAED,WAAW,OAAQ,CAEf,MAAO,CAAE,GAAG,MAAM,MAAO,GAAGkE,CAAK,CACpC,CAED,WAAW,oBAAqB,CAG5B,MAAMc,EAAa,MAAM,oBAAsB,GAC/C,UAAW5D,KAAQ8C,EACfhD,EACI,KAAK,UACLE,EACA8C,EAAM9C,CAAI,EACVE,EACAC,CACxB,EAEgB,OAAO,OAAO,KAAKD,CAAK,EAAE,OAAO0D,CAAU,CAC9C,CACJ,CACT,EAEeX,CAAS,CACxB,EAMA,SAASS,GAAYzC,EAAM,CACvB,KAAM,CAAE,OAAA8B,CAAM,EAAK9B,EAAK,YAClB,CAAE,WAAA4C,CAAY,EAAG5C,EACvB,GAAI4C,GAAcd,EAAO,OAAQ,CAI7B,MAAMe,EAAS,CAAA,EACf7E,EAAK8D,EAASnE,GAAU,CAChBA,IACIA,aAAiB,QACjBiF,EAAW,YAAYjF,EAAM,UAAU,EAAI,CAAC,EAE5CkF,EAAO,KAAKlF,CAAK,EAGrC,CAAS,EACGkF,EAAO,SAAQD,EAAW,mBAAqBC,EACtD,CACL,CC7PA,MAAMC,EAAgBzE,GAAS,CAAC0E,EAAeC,IAAgB,CAC3DzC,EAMI,CAAC,CAAC0C,EAAWC,CAAI,EAAI,OACbA,GAAQ,CAACA,KACLA,GAAQ7F,EAAa6F,EAAMF,CAAW,EACtCC,EAAYA,GAAa,IAIzBvF,EAAWuF,CAAS,GAAKA,IACzBA,EAAY,OAGb,CAACA,EAAWD,CAAW,GAKlC,CAAC,CAACC,EAAWC,CAAI,EAAG9B,IACZA,GAEA1D,EAAWuF,CAAS,GAAKA,IAClB,IAEA,CAACA,GAAwBF,EAAe,EAAEG,CAAI,EAG7D7E,CACR,CACA,EAEa8E,GAAkBL,EAAazC,CAAc,EAE7C+C,GAAYN,EAAa1C,CAAQ,ECjDjCiD,GAAU,CAEnB,MAAO,CAAC,CAAC,SAAS,kBACtB,ECFMC,GAAiB,CACnB,QAAS,EACT,MAAO,EACP,SAAU,CACd,EAEMC,GAAiB,CACnB,KAAM,EACN,KAAM,EACN,KAAM,EACN,KAAM,EACN,MAAO,EACP,OAAQ,EACR,IAAK,EACL,KAAM,EACN,KAAM,CACV,EAEMC,GAAiB,CACnB,UAAW,EACX,WAAY,EACZ,UAAW,EACX,SAAU,EACV,IAAK,CACT,EAEMC,EAAc,CAAA,EAEdC,EAAiB,CAAA,EAEVC,EAAI,SAEV,MAAMC,UAAa,IAAK,CAAE,CAEjC,MAAMC,EAAY,OAAO,IAEZrC,GAAKqC,EAAU,YAAY,EAE3BC,EAAKD,EAAU,YAAY,EAE3BE,EAAMF,EAAU,aAAa,EAE7BG,GAAW,IAAM,CAAA,EASvB,SAASC,GAAOlG,EAAMmD,EAAIoB,EAAS,CACtC,OAAO4B,EAAK,KAAMnG,EAAMmD,EAAIoB,CAAO,CACvC,CAIY,MAAC6B,GAAI,CAAC9F,EAAM+F,KAAMlB,IAAS,CAInC,MAAMrB,EAAQuC,GAAKX,EAEnB,GAAI,CAAE,SAAAY,CAAU,EAAGxC,EAKnB,GAHAwC,EACIA,IAA8BnB,EAAK,OAASA,EAAOQ,GAEnDrF,IAAS2F,GAET,OAAOK,EAGX,MAAMC,EAAMjG,EACNA,aAAgB,KACZ,EAEAA,EAAK,qBAAqB,aAAe,EAC7C,EAGN,GAAIiG,IAAQ,IAASjG,aAAgB,SACjC,OAAOA,EACHgG,GAAYX,EAAiB,CAAE,SAAAW,EAAU,GAAGxC,CAAO,EAAGA,CAClE,EAOI,MAAMrB,EAAS6C,GAAQ,QAAUY,GA0BjC,MArBc,CACV,GAAAH,EACA,KAAAzF,EACA,MAAAwD,EACA,SAAAwC,EACA,IAAKxC,EAAM,IAGX,OAAQA,EAAM,UAEd,OAAQA,EAAM,WAEd,IAAAyC,EAEA,GAAIzC,EAAM,GAEV,MAAOA,EAAM,UACb,OAAArB,CACR,CAIA,EAaA,SAAS0D,EAAKK,EAAUxG,EAAMmD,EAAKM,GAAIc,EAASkC,EAAO,CACnD,IAAIC,EAEJ,GAAK1G,GAAQA,EAAKmD,CAAE,GAAKnD,EAAKmD,CAAE,EAAE,OAASqD,GAAaA,EAAS,IAAMT,EACnE,OAAO/F,GAEPwG,GAAY,CAACxG,KACbyG,EAAQA,GAASD,EAAS,MAAQ,MAElCE,EACIF,EAAS,MAAQ,SAChBA,EAAS,KAAO,GACVxG,GAAQwG,EAAS,MAAQxG,EAAKgG,CAAG,EAAIhG,IAASwG,EAAS,KACxDA,EAAS,KAAO,EAChB,EAAExG,aAAgBwG,EAAS,MAC3BxG,EACAA,EAAKgG,CAAG,GAAKhG,EAAK,WAAawG,EAAS,KACxC,CAACxG,GAEP0G,GAAaF,EAAS,MAAQ,OAC1BA,EAAS,KAAO,GAAKA,EAAS,OAC9BjC,EAAU,GACVvE,EAAOwG,EAAS,KAAK,UAAU,EAAI,EACnCxG,EAAKgG,CAAG,EAAIQ,EAAS,MAErBxG,EACIwG,EAAS,KAAO,EACVA,EAAS,KACTA,EAAS,KAAO,EAChB,IAAIA,EAAS,KACbC,EACAb,EAAE,gBACE,6BACAY,EAAS,IACZ,EACDZ,EAAE,cACEY,EAAS,KACTA,EAAS,GAAK,CAAE,GAAIA,EAAS,EAAI,EAAG,MAClE,IAKI,MAAMG,EAAgB3G,EAAKmD,CAAE,EAAInD,EAAKmD,CAAE,EAAIuC,EAKtC,CAAE,MAAAkB,EAAQlB,EAAa,MAAAmB,EAAQ,CAAC,EAAKF,EAE3C,GAAI,CAAE,SAAAG,EAAU,SAAAC,CAAU,EAAGJ,EAK7B,KAAM,CAAE,SAAAL,EAAWX,EAAgB,MAAA7B,EAAQ4B,CAAW,EAAKkB,EAS3D,GAJAG,EAAWL,EAAY,GAAKK,GAAY,CAAA,EAIpCP,EAAS,QAAU,CAACE,EAAW,OAAO1G,EAO1C,GALAwG,EAAS,QAAU,CAACxG,EAAK,YAAcA,EAAK,aAAa,CAAE,KAAM,MAAM,CAAE,EAEzEwG,EAAS,OAAS1C,GACdkD,GAAUhH,EAAM8D,EAAO0C,EAAS,MAAOO,EAAUN,CAAK,EAEtDD,EAAS,WAAaF,EAAU,CAChC,MAAMW,EAAaT,EAAS,OAASxG,EAAK,WAAaA,EAEvD8G,EAAWI,GACPV,EAAS,SAITM,EACAG,EACA9D,EAEA,CAAC0D,GAAStC,EACVkC,GAASD,EAAS,MAAQ,gBAAkB,GAAQC,CAChE,CACK,CAED,OAAAzG,EAAKmD,CAAE,EAAI,CAAE,MAAOqD,EAAU,SAAAO,EAAU,SAAAD,EAAU,MAAOD,EAAQ,GAE1D7G,CACX,CAOA,SAASmH,GAAeC,EAAQ7C,EAAS,CACrC,MAAM8C,EAAY,IAAIxB,EAAK,EAAE,EACvByB,EAAU,IAAIzB,EAAK,EAAE,EAK3B,IAAI7F,EAIJ,GAFAoH,EAAO7C,EAAU,UAAY,QAAQ,EAAE8C,CAAS,EAE5C9C,EAAS,CACT,GAAI,CAAE,kBAAAgD,CAAmB,EAAGH,EAC5B,KAAOG,GAAmB,CACtB,GAAIxH,EAAUwH,CAAiB,EAAG,CAC9BvH,EAAOuH,EACP,KACH,CACDA,EAAoBA,EAAkB,kBACzC,CACJ,CAED,OAAIvH,EACAoH,EAAO,aAAaE,EAAStH,CAAI,EAEjCoH,EAAO,OAAOE,CAAO,EAGlB,CACH,UAAAD,EACA,QAAAC,CACR,CACA,CAYO,SAASJ,GAAeZ,EAAUQ,EAAUM,EAAQjE,EAAIoB,EAASkC,EAAO,CAC3EH,EACIA,GAAY,KAAO,KAAOxG,EAAQwG,CAAQ,EAAIA,EAAW,CAACA,CAAQ,EAEtE,MAAMkB,EAAeV,GAAYK,GAAeC,EAAQ7C,CAAO,EAEzD,CAAE,UAAA8C,EAAW,QAAAC,EAAS,MAAAG,CAAK,EAAKD,EAItC,IAAIE,EAKJ,MAAMC,EAAcF,GAAS,IAAI,IAMjC,IAAIG,EAAcP,EAkElB,GAhEAf,GACIrG,EAAKqG,EAAWuB,GAAU,CACtB,GAAI,OAAOA,GAAS,UAAYA,EAAM,IAAM9B,EACxC,OAGJ,MAAM+B,EAAMD,EAAM,IAAMA,EAAM,IACxBE,EAAWN,GAASK,GAAO,MAAQL,EAAM,IAAIK,CAAG,EAGlDF,GAAeN,GAAWM,IAAgBG,EAC1CJ,EAAY,OAAOC,CAAW,EAE9BA,EACIA,GAAeN,EAAUA,EAAUM,EAAY,YAGvD,MAAMI,EAAYP,EAAQM,EAAWH,EAErC,IAAIK,EAAgBD,EAEpB,GAAKH,EAAM,GAiBPI,EAAgB9B,EAAK0B,EAAOG,EAAW7E,EAAIoB,EAASkC,CAAK,MAjB9C,CACX,MAAMyB,EAAOL,EAAQ,GAEjB,EAAEI,aAAyB,OAC3BA,aAAyBpC,EAEzBoC,EAAgB,IAAI,KAAKC,CAAI,EAIxBD,EAAc,MAAQC,IAE3BD,EAAc,KAAOC,EAEzC,CAKgBD,GAAiBL,IACjBH,GAASE,EAAY,OAAOM,CAAa,EACrC,CAACD,GAAaP,GACdL,EAAO,aAAaa,EAAeL,CAAW,EAE9CH,GACIG,GAAeN,GACfK,EAAY,IAAIC,CAAW,GACxBI,GAAaV,EACpBF,EAAO,aAAaa,EAAeX,CAAO,GAE1CF,EAAO,aAAaa,EAAeD,CAAS,EAC5CJ,EAAcK,IAIlBH,GAAO,OACPJ,EAAYA,GAAa,IAAI,IAC7BA,EAAU,IAAII,EAAKG,CAAa,EAEhD,CAAS,EAELL,EAAcA,GAAeN,EAAUA,EAAUM,EAAY,YAEzDd,GAAYc,GAAeN,EAE3B,KAAOM,GAAeN,GAAS,CAC3B,MAAMa,EAAeP,EACrBA,EAAcA,EAAY,YAC1BO,EAAa,OAAM,CACtB,CAGL,OAAAR,GAAeA,EAAY,QAAS3H,GAASA,EAAK,OAAM,CAAE,EAE1DwH,EAAa,MAAQE,EAEdF,CACX,CAUO,SAASR,GAAUhH,EAAM8D,EAAOsE,EAAWrB,EAAUN,EAAO,CAC/D,UAAWqB,KAAOhE,EACd,EAAEgE,KAAOM,IACLC,EAAYrI,EAAM8H,EAAKhE,EAAMgE,CAAG,EAAG,KAAMrB,EAAOM,CAAQ,EAEhE,UAAWe,KAAOM,EACdC,EAAYrI,EAAM8H,EAAKhE,EAAMgE,CAAG,EAAGM,EAAUN,CAAG,EAAGrB,EAAOM,CAAQ,CAE1E,CAWO,SAASsB,EAAYrI,EAAM8H,EAAKQ,EAAWC,EAAW9B,EAAOM,EAAU,CAU1E,GATAe,EAAMA,GAAO,SAAW,CAACrB,EAAQ,YAAcqB,EAE/CQ,EAAYA,GAAoB,KAChCC,EAAYA,GAAoB,KAE5BT,KAAO9H,GAAQuF,GAAeuC,CAAG,IACjCQ,EAAYtI,EAAK8H,CAAG,GAGpB,EAAAS,IAAcD,GAAa7C,GAAeqC,CAAG,GAAKA,EAAI,CAAC,GAAK,KAEhE,GACIA,EAAI,CAAC,GAAK,KACVA,EAAI,CAAC,GAAK,MACTnI,EAAW4I,CAAS,GAAK5I,EAAW2I,CAAS,GAE9CE,GAASxI,EAAM8H,EAAI,MAAM,CAAC,EAAGS,EAAWxB,CAAQ,UACzCe,GAAO,MACVS,IACI5I,EAAW4I,CAAS,EACpBA,EAAUvI,CAAI,EAEduI,EAAU,QAAUvI,WAGrB8H,GAAO,QAAS,CAKvB,KAAM,CAAE,MAAAW,CAAO,EAAGzI,EAElBsI,EAAYA,GAAa,GACzBC,EAAYA,GAAa,GAEzB,MAAMG,EAAe7I,EAASyI,CAAS,EACjCK,EAAe9I,EAAS0I,CAAS,EAEvC,GAAIG,EACA,UAAWZ,KAAOQ,EACd,GAAIK,EACA,EAAEb,KAAOS,IAAcK,EAAiBH,EAAOX,EAAK,IAAI,MAExD,OAKZ,GAAIa,EACA,UAAWb,KAAOS,EAAW,CACzB,MAAM3I,EAAQ2I,EAAUT,CAAG,EACvBY,GAAgBJ,EAAUR,CAAG,IAAMlI,GACvCgJ,EAAiBH,EAAOX,EAAKlI,CAAK,CACrC,MAED6I,EAAM,QAAUF,CAE5B,KAAW,CACH,MAAMjH,EAAOwG,EAAI,CAAC,GAAK,IAAMA,EAAI,MAAM,CAAC,EAAIA,EAExCxG,IAASwG,IACP,CAACrB,GAAS,CAACjB,GAAesC,CAAG,GAAKA,KAAO9H,GACvCL,EAAW4I,CAAS,GACpB5I,EAAW2I,CAAS,GAExBtI,EAAK8H,CAAG,EAAIS,GAAoB,GACzBA,GAAa,KACpBvI,EAAK,gBAAgBsB,CAAI,EAEzBtB,EAAK,aACDsB,EACAzB,EAAS0I,CAAS,EAAI,KAAK,UAAUA,CAAS,EAAIA,CAClE,CAEK,CACL,CASO,SAASC,GAASxI,EAAMM,EAAMuI,EAAa9B,EAAU,CASxD,GAPKA,EAAS,cAIVA,EAAS,YAAe1F,GACpB0F,EAAS1F,EAAM,IAAI,EAAE,KAAKrB,EAAMqB,CAAK,GAEzCwH,EAAa,CAEb,GAAI,CAAC9B,EAASzG,CAAI,EAAG,CAEjB,MAAMgF,EACFuD,EAAY,SAAWA,EAAY,MAAQA,EAAY,QACjD,OAAO,OAAO,CAAE,EAAEA,CAAW,EAC7B,KACV7I,EAAK,iBAAiBM,EAAMyG,EAAUzB,CAAO,CAChD,CAEDyB,EAASzG,CAAI,EAAIuI,CACzB,MAEY9B,EAASzG,CAAI,IACbN,EAAK,oBAAoBM,EAAMyG,CAAQ,EACvC,OAAOA,EAASzG,CAAI,EAGhC,CAOO,SAASsI,EAAiBH,EAAOX,EAAKlI,EAAO,CAChD,IAAIkJ,EAAS,cACTlJ,GAAS,OACTkJ,EAAS,iBACTlJ,EAAQ,MAER,CAACkI,EAAI,QAAQ,GAAG,EAChBW,EAAMK,CAAM,EAAEhB,EAAKlI,CAAK,EAExB6I,EAAMX,CAAG,EAAIlI,CAErB,CC1hBA,KAAA,CAAA,OAAAmJ,EAAA,EAAA,4BAGMC,EAAQ,CACV,IAAK,aACL,KAAM,MACV,EACA,SAASC,EAAQ,CAAE,MAAAC,EAAO,IAAAC,EAAK,KAAAhE,EAAM,KAAAiE,EAAM,OAAAC,GAAU,CACjD,MAAMpH,EAAOa,KACbuC,GAAU,IAAM,CACZ,sBAAsB,IAAM,CACxB0D,GAAO,WAAU,EAAG,KAAKO,EAAkB,CACvC,GAAIH,EACJ,KAAAhE,EACA,OAAQkE,IAAW,OAASpH,EAAK,QAAQ,UAAYmH,EACrD,GAAIJ,EAAMK,CAAM,EAAI,CAAE,OAAQL,EAAMK,CAAM,CAAG,EAAG,IAChE,CAAa,CACb,CAAS,CACT,CAAK,EACD,MAAM7E,EAAS0E,IACf,OAAAjH,EAAK,OAASuC,EACP4B,GAAE,OAAQ,KAAM5B,CAAM,CACjC,CACAyE,EAAQ,MAAQ,CACZ,IAAK,OACL,MAAO,SACP,eAAgB,OAChB,KAAM,OACN,OAAQ,OACR,KAAM,IACV,EACA,MAAMM,GAAU3F,GAAEqF,CAAO,EACpB,eAAe,IAAI,2BAA2B,GAC/C,eAAe,OAAO,4BAA6BM,EAAO,EAClD,MAACC,GAAY,CAAC,CAAE,OAAAH,GAAW,CAAE,OAAQ,MAAQ,IAAK,CAACI,EAAOC,IAAY,CAC9E,MAAMC,EAAQD,EAAQ,cACjBC,EAAMD,EAAQ,EAAE,IACjBC,EAAMD,EAAQ,EAAE,EAAI,SAAS,cAAc,2BAA2B,EACtEC,EAAMD,EAAQ,EAAE,EAAE,aAAa,MAAOA,EAAQ,EAAE,GAEpD,MAAMzH,EAAO0H,EAAMD,EAAQ,EAAE,EAC7BzH,EAAK,MAAQwH,EACbxH,EAAK,KAAOyH,EAAQ,aACpBzH,EAAK,KAAOyH,EAAQ,WAAW,KAAK,OAAO,eAC3CzH,EAAK,OAASoH,EACd,MAAMO,EAAOF,EAAQ,WAAW,SAAS,MAAM,UAAU,EACzD,OAAIE,IACAF,EAAQ,WAAW,KAAK,OAAO,SAAWE,EAAK,GAAG,CAAC,GAEhD3H,CACX","x_google_ignoreList":[0,1,2,3,4,5,6,7]}